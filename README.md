# py
                                                                                    Сортировка вставками
Сортировка вставками (Insertion Sort) — это алгоритм, который строит отсортированную часть массива, поэтапно вставляя каждый новый элемент на свое правильное место среди уже отсортированных элементов.
Анализ:
Алгоритм берёт текущий элемент и ищет его позицию среди уже отсортированных элементов, двигаясь назад и сдвигая элементы, которые больше текущего.
o	Внешний цикл for пробегает по каждому элементу массива (начиная со второго элемента).
Внутренний цикл осуществляет поиск места для вставки текущего элемента среди ранее отсортированных элементов.
На каждом шаге внутреннего цикла текущий элемент сравнивается с предшествующими элементами и, если он меньше, совершается сдвиг большего элемента вправо.
o	Всего операций примерно: для первого элемента (один проход), для второго (два прохода), ..., для последнего (до n-1 проходов).
Временная сложность:
O(n)O(n) — если массив уже отсортирован, алгоритм делает линейное количество операций (только одно прохождение по массиву).
Почему O(n2)O(n2):
Двойная вложенность циклов. Во внутреннем цикле количество сравнений уменьшается с каждым шагом внешнего цикла, но суммарно достигает примерно n(n−1)/2n(n−1)/2 сравнений и примерно столько же возможных перемещений элементов. Поэтому временная сложность в худших случаях составляет O(n2)O(n2).
                                                                                    
                                                                                    Сортировка слиянием 
Определение:
Сортировка слиянием (Merge Sort) — это алгоритм, который рекурсивно разделяет массив на две части, сортирует каждую часть раздельно, а затем объединяет отсортированные части в единое целое.
Анализ:
Алгоритм основан на подходе "разделяй и властвуй": 
o	Разбиение: Массив делится на две равные части рекурсивно, пока не останутся отдельные элементы.
o	Слияние: Уже отсортированные подмассивы объединяются в одну отсортированную структуру. При объединении сравниваются первые элементы каждой подчасти, и наименьшие последовательно попадают в результирующий массив.
Временная сложность:
o	На каждом этапе рекурсии массив делится ровно пополам, что означает глубину рекурсии порядка O(log⁡n)O(logn).
o	При каждом возврате из рекурсии выполняется операция слияния, занимающая O(n)O(n) действий.
o	Следовательно, общее количество операций составляет произведение глубины рекурсии на количество операций на одном уровне, что дает O(nlog⁡n)O(nlogn).
Почему O(nlog(⁡)n)O(nlogn):
o	Алгоритм делит массив на равные части (логарифмическое количество уровней рекурсии).
o	На каждом уровне рекурсии происходит полное просматривание и объединение обоих подмассивов (линейное количество операций).
o	Поскольку оба фактора мультипликативны, итоговая временная сложность составляет O(nlog⁡n)O(nlogn

                                                                                    Сортировка пузыриками 
Определение:
Сортировка пузырьком (Bubble Sort) — это простой алгоритм, который многократно проходит по массиву, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Повторяется процесс до тех пор, пока массив не станет полностью отсортированным.
Анализ:
o	Проходы: Алгоритм совершает многократные полные прохождения по массиву.
o	Обмены: На каждом шаге соседние элементы сравниваются друг с другом, и если текущий элемент больше следующего, они меняются местами.
o	Остановка: Возможна оптимизация: если за полный проход не произошло ни одной замены, значит массив уже отсортирован, и алгоритм останавливается.
Временная сложность:
o	Самый лучший случай: O(n)O(n) — если массив уже отсортирован заранее (алгоритм обнаружит отсутствие замен и остановится).
o	Средний и худший случаи: O(n2)O(n2) — в худшем случае (массив отсортирован в обратном порядке) требуется провести около n(n−1)/2n(n−1)/2 сравнений и такое же количество обменов.
Почему O(n2)O(n2):
o	В самом плохом сценарии на первом проходе делается n−1n−1 сравнений, на втором — n−2n−2, и так далее, пока последний проход не потребует лишь одно сравнение.
o	Суммарное количество сравнений — это сумма арифметической последовательности от 1 до n−1n−1, что приблизительно равно n(n−1)/2n(n−1)/2.
o	Таким образом, временная сложность в худшем и среднем случаях — O(n2)O(n2).

                                                                                Сортировка выбором
Определение:
Сортировка выбором (Selection Sort) — это алгоритм, который разделяет массив на две части: отсортированную и неотсортированную. На каждом шаге он находит минимальный элемент в неотсортированной части и меняет его местами с первым элементом этой части.
Анализ:
o	Поиск минимума: Алгоритм находит минимальный элемент в неотсортированной части массива.
o	Замена: Найденный минимум меняется местами с первым элементом неотсортированной части.
o	Повторение: Такой процесс повторяется до полного завершения сортировки.
Временная сложность:
o	Лучший случай: O(n2)O(n2) — алгоритм всегда выполняет n−1n−1 полных просмотров массива вне зависимости от изначального порядка элементов.
o	Средний и худший случаи: O(n2)O(n2) — каждый проход включает просмотр оставшихся элементов и замену минимального элемента.
Почему O(n2)O(n2):
o	Внешний цикл выполняется n−1n−1 раз.
o	Внутренний цикл для нахождения минимума проходит через оставшиеся n−in−i элементов, где ii — номер итерации внешнего цикла.
o	Сумма всех внутренних циклов (сумма от 1 до n−1n−1) составляет примерно n(n−1)/2n(n−1)/2, что соответствует временной сложности O(n2)O(n2).
                                                                            
                                                                            Сортировка Шелла
Определение:
Сортировка Шелла (Shell Sort) — это улучшенная версия сортировки вставками, использующая специальный способ выбора расстояний ("шагов") между элементами, подлежащими сравнению и сортировке. Изначально элементы далеко отстоят друг от друга, а по мере уменьшения расстояния переходят к обычной сортировке вставками.
Анализ:
o	Начальный этап: Задаваемый шаг определяет расстояние между элементами, которые сравниваются и переставляются.
o	Постепенное уменьшение шага: Расстояние постепенно уменьшается, приводя алгоритм ближе к классической сортировке вставками.
o	Эффективность: Чем больше шаг вначале, тем быстрее крупные элементы достигают приблизительного своего положения, ускоряя дальнейшую сортировку.
Временная сложность:
o	Лучший случай: O(nlog⁡n)O(nlogn) — возможен при удачном выборе начальных интервалов и благоприятном расположении элементов.
o	Средний и худший случаи: зависят от выбранной стратегии задания шагов, но обычно варьируются от O(n3/2)O(n3/2) до O(n5/4)O(n5/4).
Почему варьируется сложность:
o	Выбор конкретных шагов сильно влияет на производительность: оптимальный выбор интервала улучшает время работы, но точное доказательство точной временной сложности затруднительно из-за многообразия подходов к выбору шага.
o	Наиболее известные схемы задания шагов включают методы Марчинского-Кнута (Knuth's sequence) и Хакмена-Хиббарда (Hibbard’s increments), которые обеспечивают хорошую производительность, близкую к O(n3/2)O(n3/2).
Таким образом, Shell Sort сочетает простоту идеи с потенциалом улучшения быстродействия по сравнению с классическими методами типа Bubble Sort или Selection Sort.
                                                                        
                                                                        Быстрая сортировка 
Определение:
Быстрая сортировка (Quick Sort) — это высокоэффективный алгоритм сортировки, основанный на принципах «разделяй и властвуй».# Определение:Быстрая сортировка (Quick Sort) — это высокоэффективный алгоритм сортировки, основанный на принципах «разделяй и властвуй». Алгоритм выбирает опорный элемент (pivot), распределяет остальные элементы массива относительно него (меньшие — слева, большие — справа), затем рекурсивно сортирует обе полученные части.
Анализ:
o	Выделение опорного элемента: Опорный элемент выбирается из массива (обычно первый, последний или центральный элемент).
o	Разбиение: Массив делится на две части относительно опорного элемента: элементы, меньшие опорного, идут влево, а большие — вправо.
o	Рекурсия: Процедура повторяется для каждой из полученных частей до тех пор, пока весь массив не окажется отсортированным.
Временная сложность:
o	Лучший случай: O(nlog⁡n)O(nlogn) — возникает, когда массив идеально балансируется при каждом разбиении.
o	Средний случай: O(nlog⁡n)O(nlogn) — типичное поведение Quick Sort при случайных входных данных.
o	Худший случай: O(n2)O(n2) — происходит, если опорный элемент постоянно оказывается минимальным или максимальным, что ведет к дисбалансу и большим затратам ресурсов.
Почему O(nlog⁡n)O(nlogn) в среднем:
o	Оптимальность обусловлена глубиной рекурсии, равной примерно log⁡nlogn, и стоимостью каждой рекурсивной процедуры — порядка O(n)O(n) (прохождение по массиву и разделение).
o	Быстрая сортировка эффективно решает проблему неравномерного распределения элементов при разумном выборе опорного элемента, что обеспечивает высокую скорость сортировки на большинстве реальных данных.
Таким образом, Quick Sort обладает превосходной производительностью на средних и больших объемах данных, став одним из самых популярных методов сортировки в современных приложениях.
                                                                    
                                                                    Пирамидальная сортировка 
Определение:
Пирамидальная сортировка (Heap Sort) — это алгоритм сортировки, основанный на структуре данных бинарная куча (heap). Бинарная куча — это структура данных, организованная как дерево, в которой каждый родительский узел больше (или меньше) своих дочерних узлов. Алгоритм преобразует массив в кучу, извлекает максимальный элемент, уменьшает размер кучи и повторяет процедуру до полной сортировки.
Анализ:
o	Формирование кучи: Преобразование массива в бинарную кучу («груду»), где каждый элемент удовлетворяет условию структуры кучи.
o	Извлечение максимального элемента: Извлекается корень кучи (самый большой элемент), ставится в конец массива, а сама куча уменьшается на единицу.
o	Исправление структуры: Корень обновляется, восстанавливая свойства кучи, и процедура повторяется.
Временная сложность:
o	Лучший случай: O(nlog⁡n)O(nlogn) — формирование начальной кучи занимает O(n)O(n), извлечение корня и восстановление свойств занимают O(log⁡n)O(logn) на каждой итерации.
o	Средний и худший случаи: O(nlog⁡n)O(nlogn) — независимо от исходного расположения элементов, все операции формируют фиксированную временную зависимость.
Почему O(nlog⁡n)O(nlogn):
o	Формирование первоначальной кучи возможно за O(n)O(n) операций, так как каждый уровень дерева наполняется за постоянное время.
o	Каждый шаг извлечения корня и восстановления кучи занимает O(log⁡n)O(logn), так как высота кучи равна log⁡nlogn.
o	Повторение этих операций nn раз приводит к итоговому выражению O(nlog⁡n)O(nlogn).
Таким образом, пирамидальная сортировка обладает устойчивым временем выполнения, хотя и немного уступая некоторым другим продвинутым алгоритмам по средней скорости. Зато она гарантирует стабильную производительность и часто используется в системах реального времени и встроенных устройствах.
                                                                   
                                                                    Последовательный поиск

Определение:
Последовательный поиск (Linear Search) — это самый простой алгоритм поиска, при котором искомый элемент последовательно сравнивается с каждым элементом списка, начиная с начала, до обнаружения совпадения или достижения конца списка.
Анализ:
o	Просмотр элементов: Осуществляет последовательное сканирование массива, сравнивая каждый элемент с заданным целевым значением.
o	Нахождение совпадения: Остановка поиска происходит, как только найден нужный элемент или достигнут конец массива.
o	Продолжительность: Линейно возрастает вместе с размером массива.
Временная сложность:
o	Лучший случай: O(1)O(1) — элемент находится в самом начале массива, и поиск немедленно завершается.
o	В лучшем случае поиск заканчивается мгновенно, но такая ситуация маловероятна на больших объемах данных.
o	Так как большинство ситуаций требуют просмотра значительной доли элементов, временная сложность обычно обозначается как O(n)O(n).
Таким образом, последовательный поиск — простой и надежный алгоритм, подходящий для небольших массивов или списков без предварительной организации данных.
                                                                      
                                                                  Бинарный поиск

Определение:
Бинарный поиск (Binary Search) — это эффективный алгоритм поиска, применяемый к отсортированным данным. Алгоритм многократно делит область поиска пополам, сужая границы области до тех пор, пока не найдёт целевой элемент или не убедится в отсутствии нужного значения.
Анализ:
o	Проверка середины: Посередине массива проверяется значение, и оно сравнивается с искомым элементом.
o	Сужение границ: Если значение в середине меньше цели, поиск продолжается в правой половине; если больше — в левой.
o	Повторы: Данная процедура повторяется до тех пор, пока цель не найдена или область поиска не исчерпалась.
Временная сложность:
o	Лучший случай: O(1)O(1) — элемент находится точно посередине массива, поиск мгновенный.
o	Средний и худший случаи: O(log⁡n)O(logn) — в худшем случае (если элемент отсутствует или находится на краю) требуется примерно log⁡2nlog2n итераций для поиска, где nn — размер массива.
Почему O(log⁡n)O(logn):
o	Каждое сравнение снижает область поиска вдвое.
o	Необходимое количество итераций — это степень двойки, необходимая для сокращения массива до единицы, что соответствует log⁡2nlog2n.
o	Даже в самом неблагоприятном случае число шагов остаётся сравнительно небольшим по отношению к размеру массива.
Таким образом, Binary Search является чрезвычайно эффективным способом поиска в больших упорядоченных коллекциях, обеспечивая значительное сокращение времени поиска по сравнению с простым линейным поиском
                                                          
                                                          Интерполирующий поиск
Определение:
Интерполирующий поиск (Interpolation Search) — это усовершенствованный алгоритм поиска, предназначенный для равномерных и упорядоченных массивов. Вместо простого деления пополам, как в бинарном поиске, интерполирующий поиск использует формулу, определяющую вероятное местоположение искомого элемента на основе разницы между ним и граничными значениями массива.
Анализ:
o	Оценка местонахождения: На основе значений минимального и максимального элементов массива рассчитывается предположительное местоположение искомого элемента.
o	Сравнение: Находится элемент в указанной позиции и сравнивается с целью.
o	Изменение границ: Если найдено несоответствие, соответственно изменяются границы поиска (левая или правая граница изменяется в зависимости от результата сравнения).
o	Попытки: Процедура повторяется, пока не будет обнаружен элемент или область поиска не сузится до нуля.
Временная сложность:
o	Лучший случай: O(1)O(1) — элемент находится прямо в рассчитанной позиции.
o	Средний случай: O(log⁡log⁡n)O(loglogn) — ожидается, что каждый шаг существенно сокращает область поиска.
o	Худший случай: O(n)O(n) — если распределение элементов массива сильно отличается от равномерного (например, в случае кластеризации элементов), поиск может оказаться столь же долгим, как и линейный поиск.
Почему O(log⁡log⁡n)O(loglogn) в среднем:
o	Интерполирующий поиск предполагает, что данные равномерно распределены, позволяя точнее определять местоположение элемента.
o	При таком условии каждый шаг сокращает область поиска гораздо эффективнее, чем простое деление пополам, достигая эффективности O(log⁡log⁡n)O(loglogn).
o	Тем не менее, при нарушении условия равномерности данных, эффективность снижается до уровня обычного линейного поиска.
Таким образом, Interpolation Search полезен для больших упорядоченных массивов с равномерно распределёнными данными, обеспечивая значительный выигрыш в скорости поиска по сравнению с бинарным поиском.
                                                                    
                                                                    Поиск фибоначи
Определение:
Фибоначчиевый поиск (Fibonacci Search) — это метод поиска в отсортированном массиве, аналогичный бинарному поиску, но использующий числовой ряд Фибоначчи для расчёта следующей точки проверки. Отличительной особенностью является способность уменьшить размер исследуемой области в зависимости от коэффициентов ряда Фибоначчи, что позволяет иногда достичь чуть большей эффективности по сравнению с обычным бинарным поиском.
Анализ:
o	Расчёт точки проверки: Используя числа Фибоначчи, вычисляется ближайшая к середине точка массива, исходя из соотношения между соседними членами ряда.
o	Сравнение: Значение в точке проверки сравнивается с искомым элементом.
o	Корректировка областей: В зависимости от результата сравнения корректируются границы поиска (уменьшается верхняя или нижняя граница).
o	Повторение: Процесс повторяется, пока не найдётся искомый элемент или область поиска не сократится до пустоты.
Временная сложность:
o	Лучший случай: O(1)O(1) — элемент находится в самой первой проверочной точке.
o	Средний и худший случаи: O(log⁡n)O(logn) — подобно бинарному поиску, фибоначчий поиск сводит количество операций к числу порядка log⁡nlogn, но теоретически чуть более эффективен за счёт лучшего подбора точек проверки.
Почему O(log⁡n)O(logn):
o	Числа Фибоначчи позволяют минимизировать количество сравнений, стремясь к минимальной длине отрезков поиска.
o	Хотя эффективность слегка выше бинарного поиска, разница невелика, и общая временная сложность всё равно относится к классу O(log⁡n)O(logn).
Таким образом, Fibonacci Search сохраняет преимущества бинарного поиска, предлагая небольшую потенциальную выгоду за счёт особенностей расчётов точек проверки, особенно полезную в некоторых специфических ситуациях.
				
