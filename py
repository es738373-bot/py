                                                                    Сортировка пузыриком

def bubble_sort(arr):
    """
    Реализует алгоритм сортировки пузырьком.
    """
    n = len(arr)  # Определяем длину массива
    for i in range(n):  # Внешний цикл, управляющий числом проходов
        # Установим флажок для выхода из цикла, если перестановок не было
        already_sorted = True
        # Внутренний цикл, сравнивающий смежные элементы
        for j in range(n - i - 1):
            # Если текущий элемент больше следующего, меняем их местами
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
                # Есть перестановка, значит массив еще не отсортирован
                already_sorted = False
        # Если на протяжении прохода перестановок не было, значит массив уже отсортирован
        if already_sorted:
            break


if __name__ == "__main__":
    # Исходный массив для сортировки
    array = [64, 34, 25, 12, 22, 11, 90]

    print("Исходный массив:", array)

    # Вызываем функцию сортировки пузырьком
    bubble_sort(array)

    print("Отсортированный массив:", array)
Исходный массив: 64,34,25,12,22,11,90
Получившийся:11,12,22,25,34,64,90


                                                                              СОРТИРОВКА ШЕЛЛА
def shell_sort(arr):
    """
    Реализует алгоритм сортировки Шелла.
    """
    n = len(arr)  # Определяем длину массива
    gap = n // 2  # Начальный шаг (промежуток) равен половине длины массива

    # Продолжаем, пока промежуток (gap) больше нуля
    while gap > 0:
        # Внешний цикл для сортировки каждого поднабора с шагом gap
        for i in range(gap, n):
            # Сохраняем текущий элемент
            current_value = arr[i]
            position = i

            # Внутрь сортируем подмассив, двигая элементы назад
            while position >= gap and arr[position - gap] > current_value:
                # Переносим больший элемент на позицию gap вперёд
                arr[position] = arr[position - gap]
                position -= gap  # Идём к предыдущей позиции с шагом gap

            # Помещаем текущий элемент на своё место
            arr[position] = current_value

        # Сокращаем шаг (промежуток) вдвое
        gap //= 2


if __name__ == "__main__":
    # Исходный массив для сортировки
    array = [64, 34, 25, 12, 22, 11, 90]

    print("Исходный массив:", array)

    # Вызываем функцию сортировки Шелла
    shell_sort(array)

    print("Отсортированный массив:", array)
Исходный массив: 64,34,25,12,22,11,90
Получившийся:11,12,22,25,34,64,90


                                                                                                Последовательный поиск
def sequential_search(arr, target):
    """
    Реализует алгоритм последовательного поиска.
    """
    # Проходим по каждому элементу массива
    for i in range(len(arr)):
        # Если текущий элемент равен искомому, возвращаем его индекс
        if arr[i] == target:
            return i
    # Если элемент не найден, возвращаем None
    return None


if __name__ == "__main__":
    # Исходный массив для поиска
    array = [64, 34, 25, 12, 22, 11, 90]
    # Целевой элемент для поиска
    search_value = 25

    print(f'Исходный массив: {array}')

    # Вызываем функцию последовательного поиска
    result = sequential_search(array, search_value)

    # Выводим результат поиска
    if result is not None:
        print(f'Элемент {search_value} найден на позиции {result}.')
    else:
        print(f'Элемент {search_value} не найден.')
Исходный массив: 64,34,25,12,22,11,90
Получившийся:11,12,22,25,34,64,90

                                                                                            Фибоначи поиск

def fibonacci_search(arr, target):
    """
    Реализует алгоритм поиска по методу Фибоначчи.
    """
    # Генератор чисел Фибоначчи
    def fib_gen():
        a, b = 0, 1
        yield a
        yield b
        while True:
            a, b = b, a + b
            yield b

    # Получаем генератор чисел Фибоначчи
    fib = fib_gen()

    # Находим наименьшее число Фибоначчи, большее или равное длине массива
    m = next(fib)
    while m < len(arr):
        m = next(fib)

    # Компенсируем разницу в размере массива и числе Фибоначчи
    offset = -1
    k = m - len(arr)

    # Сохраняем два последних числа Фибоначчи
    fm = next(fib)
    fmm1 = next(fib)
    fmm2 = next(fib)

    # Пока сегмент массива достаточно велик для поиска
    while fmm2 > 1:
        # Вычисляем индекс для проверки
        i = min(offset + fmm2, len(arr)-1)

        # Если элемент меньше целевого, движемся вправо
        if arr[i] < target:
            fmm2 = fmm1
            fmm1 = fm
            fm = fmm2 + fmm1
            offset = i
        # Если элемент больше целевого, движемся влево
        elif arr[i] > target:
            fm = fmm2
            fmm1 = fmm1 - fmm2
            fmm2 = fm - fmm1
        # Если элемент найден, возвращаем его индекс
        else:
            return i

    # Дополнительная проверка для остаточных элементов
    if fmm1 and arr[offset + 1] == target:
        return offset + 1

    # Если элемент не найден, возвращаем -1
    return -1


if __name__ == "__main__":
    # Исходный отсортированный массив для поиска
    array = [11, 22, 25, 34, 64, 90]
    # Целевой элемент для поиска
    search_value = 25

    print(f'Исходный массив: {array}')

    # Вызываем функцию поиска по методу Фибоначчи
    result = fibonacci_search(array, search_value)

    # Выводим результат поиска
    if result != -1:
        print(f'Элемент {search_value} найден на позиции {result}.')
    else:
        print(f'Элемент {search_value} не найден.')
Исходный массив: 64,34,25,12,22,11,90
Получившийся:11,12,22,25,34,64,90
