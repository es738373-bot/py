                                                                            сортировка выбором;
C++ #include <iostream> // Подключаем библиотеку ввода-вывода

using namespace std; // Используем пространство имен std, чтобы избежать записи std:: перед функциями ввода-вывода

// Функция для реализации сортировки выбором
void selectionSort(int arr[], int n) {
    for (int i = 0; i < n - 1; ++i) {          // Внешний цикл проходит по каждому элементу массива кроме последнего
        int minIndex = i;                      // Предполагаем, что первый элемент текущего шага является минимальным
        
        // Внутренний цикл находит реальный минимум среди оставшихся элементов
        for (int j = i + 1; j < n; ++j) {
            if (arr[j] < arr[minIndex]) {      // Если найден новый меньший элемент, обновляем индекс минимального элемента
                minIndex = j;
            }
        }
    
        // Меняем местами текущий элемент и найденный минимальный элемент
        swap(arr[i], arr[minIndex]);           // Стандартная библиотека STL имеет встроенную функцию swap()
    }
}

// Основная программа
int main() {
    const int SIZE = 8;                        // Определяем размер массива
    int array[] = {64, 25, 12, 22, 11, 90, 5, 1}; // Пример несортированного массива
    
    cout << "Исходный массив:\n";
    for (int i = 0; i < SIZE; ++i) {          // Вывод исходного массива
        cout << array[i] << ' ';
    }
    cout << endl;
    
    selectionSort(array, SIZE);               // Сортируем массив функцией selectionSort
    
    cout << "\nОтсортированный массив:\n";
    for (int i = 0; i < SIZE; ++i) {          // Вывод отсортированного массива
        cout << array[i] << ' ';
    }
    cout << endl;
    
    return 0;                                 // Завершаем программу успешно
}

Вывод
Исходный массив:
64 25 12 22 11 90 5 1 

Отсортированный массив:
1 5 11 12 22 25 64 90 

                                                                                        Сортировка вставками 
#include <iostream> // Заголовочный файл для ввода-вывода

using namespace std; // Пространство имен std, чтобы не указывать std:: перед каждым объектом

// Функция для сортировки массива методом вставок
void insertionSort(int arr[], int n) {
    int key, j;                       // Переменные для хранения временного ключа и индекса элемента
    for (int i = 1; i < n; i++) {     // Начинаем обход массива с первого элемента (i=1),
                                      // считая первый элемент уже отсортированным
        key = arr[i];                 // Сохраняем текущий элемент в переменную key
        j = i - 1;                    // Идем обратно по уже отсортированной части массива
        
        /*
         * Пока предыдущие элементы больше текущего и индексы действительны,
         * сдвигаем большие элементы вперед
         */
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];      // Копируем больший элемент вперед
            j--;                      // Двигаемся к предыдущему элементу
        }
        
        // Размещаем наш ключевой элемент на правильную позицию
        arr[j + 1] = key;
    }
}

// Основная функция программы
int main() {
    int array[] = {12, 11, 13, 5, 6}; // Исходный массив для сортировки
    int length = sizeof(array) / sizeof(array[0]); // Определяем длину массива
    
    // Печать исходного массива
    cout << "Исходный массив: ";
    for (int i = 0; i < length; i++) {
        cout << array[i] << " ";
    }
    cout << endl;
    
    // Сортировка массива методом вставок
    insertionSort(array, length);
    
    // Печать отсортированного массива
    cout << "Отсортированный массив: ";
    for (int i = 0; i < length; i++) {
        cout << array[i] << " ";
    }
    cout << endl;
    
    return 0; // Успешное завершение программы

}
Исходный массив:12,11,13,5,6
Получившийся:5,6,11,12,13
                                                                                                                                      Сортировка слиянием
  

#include <iostream> // Стандартная библиотека для операций ввода-вывода
#include <vector>   // Контейнер vector для динамического управления памятью

using namespace std; // Пространство имен std для удобства использования стандартных компонентов

// Вспомогательная функция merge для объединения двух отсортированных половинок массива
void merge(vector<int>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;        // Размер первой половины
    int n2 = right - mid;           // Размер второй половины

    // Создание временных массивов для левой и правой половин
    vector<int> L(n1), R(n2);

    // Копирование данных в временные массивы
    for (int i = 0; i < n1; i++) {
        L[i] = arr[left + i];        // Левая половина
    }
    for (int j = 0; j < n2; j++) {
        R[j] = arr[mid + 1 + j];    // Правая половина
    }

    // Индексы для трех массивов
    int i = 0, j = 0, k = left;

    // Объединение отсортированных половин в общий массив
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {          // Если левый элемент меньше правого
            arr[k++] = L[i++];       // Добавляем элемент из левого массива
        } else {
            arr[k++] = R[j++];       // Иначе добавляем элемент из правого массива
        }
    }

    // Остались ли еще элементы в левом массиве?
    while (i < n1) {
        arr[k++] = L[i++];
    }

    // Остались ли еще элементы в правом массиве?
    while (j < n2) {
        arr[k++] = R[j++];
    }
}

// Рекурсивная функция сортировки слиянием
void mergeSort(vector<int>& arr, int left, int right) {
    if (left < right) {                   // Если диапазон массива больше одного элемента
        int mid = left + (right - left) / 2; // Находим середину диапазона
        
        // Сортируем левую половину рекурсивно
        mergeSort(arr, left, mid);
        
        // Сортируем правую половину рекурсивно
        mergeSort(arr, mid + 1, right);
        
        // Объединяем обе отсортированные половины
        merge(arr, left, mid, right);
    }
}

// Основная функция программы
int main() {
    vector<int> array = {38, 27, 43, 3, 9, 82, 10}; // Пример массива для сортировки
    int size = array.size();                         // Определяем размер массива

    // Печать исходного массива
    cout << "Исходный массив: ";
    for (auto num : array) {
        cout << num << " ";
    }
    cout << endl;

    // Вызов функции сортировки
    mergeSort(array, 0, size - 1);

    // Печать отсортированного массива
    cout << "Отсортированный массив: ";
    for (auto num : array) {
        cout << num << " ";
    }
    cout << endl;

    return 0; // Успешное завершение программы
}
Исходный массив: 12,11,13,5,6
Получившийся:5,6,11,12,13


                                                                                                                       БЫСТРАЯ СОРТИРОВКА 
#include <iostream> // Подключаем библиотеку для операций ввода-вывода
#include <vector>   // Используем динамический массив (контейнер vector)

using namespace std; // Используем пространство имен std для упрощения доступа к функциям

// Вспомогательная функция для поиска опорного элемента и перераспределения массива
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];    // Выбираем последний элемент в качестве опорного
    int i = low - 1;          // Индекс для элементов, меньших опорного

    // Проходим по массиву, перемещая элементы, меньшие опорного, влево
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) { // Если текущий элемент меньше опорного
            i++;             // Инкрементируем индекс меньших элементов
            swap(arr[i], arr[j]); // Меняем местами текущий элемент с элементом на позиции i
        }
    }

    // Помещаем опорный элемент на правильную позицию
    swap(arr[i + 1], arr[high]);
    return i + 1; // Возвращаем индекс опорного элемента
}

// Реализуем алгоритм быстрой сортировки
void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {                     // Если есть элементы для сортировки
        int pi = partition(arr, low, high);// Находим точку раздела массива

        // Рекурсивно сортируем левую и правую части массива
        quickSort(arr, low, pi - 1);      // Сортируем левую часть
        quickSort(arr, pi + 1, high);     // Сортируем правую часть
    }
}

// Основная функция программы
int main() {
    vector<int> array = {64, 34, 25, 12, 22, 11, 90}; // Исходный массив для сортировки
    int size = array.size();                        // Определяем размер массива

    // Выводим исходный массив
    cout << "Исходный массив: ";
    for (const auto& elem : array) {
        cout << elem << " ";
    }
    cout << endl;

    // Вызываем функцию быстрой сортировки
    quickSort(array, 0, size - 1);

    // Выводим отсортированный массив
    cout << "Отсортированный массив: ";
    for (const auto& elem : array) {
        cout << elem << " ";
    }
    cout << endl;

    return 0; // Завершаем программу успешно
}
Исходный массив: 64,34,25,12,22,11,90
Получившийся:11,12,22,25,34,64,90


                                                                                                                        Пирамидальная сортировка 
#include <iostream> // Подключаем библиотеку для операций ввода-вывода
#include <vector>   // Используем динамический массив (контейнер vector)

using namespace std; // Используем пространство имен std для упрощения доступа к функциям

// Вспомогательная функция для поиска опорного элемента и перераспределения массива
int partition(vector<int>& arr, int low, int high) {
    int pivot = arr[high];    // Выбираем последний элемент в качестве опорного
    int i = low - 1;          // Индекс для элементов, меньших опорного

    // Проходим по массиву, перемещая элементы, меньшие опорного, влево
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) { // Если текущий элемент меньше опорного
            i++;             // Инкрементируем индекс меньших элементов
            swap(arr[i], arr[j]); // Меняем местами текущий элемент с элементом на позиции i
        }
    }

    // Помещаем опорный элемент на правильную позицию
    swap(arr[i + 1], arr[high]);
    return i + 1; // Возвращаем индекс опорного элемента
}

// Реализуем алгоритм быстрой сортировки
void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {                     // Если есть элементы для сортировки
        int pi = partition(arr, low, high);// Находим точку раздела массива

        // Рекурсивно сортируем левую и правую части массива
        quickSort(arr, low, pi - 1);      // Сортируем левую часть
        quickSort(arr, pi + 1, high);     // Сортируем правую часть
    }
}

// Основная функция программы
int main() {
    vector<int> array = {64, 34, 25, 12, 22, 11, 90}; // Исходный массив для сортировки
    int size = array.size();                        // Определяем размер массива

    // Выводим исходный массив
    cout << "Исходный массив: ";
    for (const auto& elem : array) {
        cout << elem << " ";
    }
    cout << endl;

    // Вызываем функцию быстрой сортировки
    quickSort(array, 0, size - 1);

    // Выводим отсортированный массив
    cout << "Отсортированный массив: ";
    for (const auto& elem : array) {
        cout << elem << " ";
    }
    cout << endl;

    return 0; // Завершаем программу успешно
}
Исходный массив: 64,34,25,12,22,11,90
Получившийся:11,12,22,25,34,64,90

                                                                                                                  БИНАРНЫЙ ПОИСК
  
#include <iostream> // Подключаем библиотеку для операций ввода-вывода
#include <vector>   // Используем динамический массив (контейнер vector)

using namespace std; // Используем пространство имен std для упрощения доступа к функциям

// Реализуем алгоритм бинарного поиска
bool binarySearch(const vector<int>& arr, int target) {
    int left = 0;         // Левая граница поиска
    int right = arr.size() - 1; // Правая граница поиска

    // Продолжаем искать, пока левая граница не пересеклась с правой
    while (left <= right) {
        int middle = left + (right - left) / 2; // Находим среднюю позицию

        // Если середина совпадает с искомым элементом, возвращаем успех
        if (arr[middle] == target) {
            return true;
        }

        // Если центр меньше цели, смотрим в правую половину
        if (arr[middle] < target) {
            left = middle + 1;
        } else { // Если центр больше цели, смотрим в левую половину
            right = middle - 1;
        }
    }

    // Если элемент не найден, возвращаем неуспех
    return false;
}

// Основная функция программы
int main() {
    vector<int> array = {11, 22, 25, 34, 64, 90}; // Исходный отсортированный массив для поиска
    int searchValue = 25;                         // Целевой элемент для поиска

    // Выводим исходный массив
    cout << "Исходный массив: ";
    for (const auto& elem : array) {
        cout << elem << " ";
    }
    cout << endl;

    // Вызываем функцию бинарного поиска
    bool found = binarySearch(array, searchValue);

    // Сообщаем результат поиска
    if (found) {
        cout << "Элемент " << searchValue << " найден." << endl;
    } else {
        cout << "Элемент " << searchValue << " не найден." << endl;
    }

    return 0; // Завершаем программу успешно
Исходный массив: 64,34,25,12,22,11,90
Получившийся:11,12,22,25,34,64,90
}
                                                                                                                

                                                                                                                            ИНТЕРПОЛИРУЮЩИЙ ПОИСК
#include <iostream> // Подключаем библиотеку для операций ввода-вывода
#include <vector>   // Используем динамический массив (контейнер vector)

using namespace std; // Используем пространство имен std для упрощения доступа к функциям

// Реализуем алгоритм интерполирующего поиска
bool interpolationSearch(const vector<int>& arr, int target) {
    int low = 0;              // Нижняя граница поиска
    int high = arr.size() - 1; // Верхняя граница поиска

    // Продолжаем поиск, пока низшая граница не превышает высшую
    while ((low <= high) && (target >= arr[low]) && (target <= arr[high])) {
        // Интерполяционная формула для расчета возможной позиции
        double pos = low + (((double)(high - low) /
                             (arr[high] - arr[low])) *
                            (target - arr[low]));

        // Округляем позицию до ближайшего целого числа
        int index = static_cast<int>(pos);

        // Если элемент найден, возвращаем успех
        if (arr[index] == target) {
            return true;
        }

        // Если элемент больше ожидаемого, двигаемся вправо
        if (arr[index] < target) {
            low = index + 1;
        } else { // Если элемент меньше ожидаемого, двигаемся влево
            high = index - 1;
        }
    }

    // Если элемент не найден, возвращаем неуспех
    return false;
}

// Основная функция программы
int main() {
    vector<int> array = {11, 22, 25, 34, 64, 90}; // Исходный отсортированный массив для поиска
    int searchValue = 25;                         // Целевой элемент для поиска

    // Выводим исходный массив
    cout << "Исходный массив: ";
    for (const auto& elem : array) {
        cout << elem << " ";
    }
    cout << endl;

    // Вызываем функцию интерполирующего поиска
    bool found = interpolationSearch(array, searchValue);

    // Сообщаем результат поиска
    if (found) {
        cout << "Элемент " << searchValue << " найден." << endl;
    } else {
        cout << "Элемент " << searchValue << " не найден." << endl;
    }

    return 0; // Завершаем программу успешно 
Исходный массив: 64,34,25,12,22,11,90
Получившийся:11,12,22,25,34,64,90
